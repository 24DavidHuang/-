#include <stdio.h>
// 定义一个函数，用于计算两个整数的最大值
int max(int a, int b) {
    return a > b ? a : b;
}

// 定义一个函数，用于求解馅饼规则问题
void pie_rule(int n, int slices[]) {
    // 定义一个二维数组，用于存储每个参与者在不同情况下的最优策略
    // dp[i][j]表示从第i个馅饼到第j个馅饼的区间内，当前拥有决策者令牌的参与者能获得的最大切片数
    int dp[n][n];
    // 定义一个二维数组，用于存储每个区间内的切片总数
    // sum[i][j]表示从第i个馅饼到第j个馅饼的区间内的切片总数
    int sum[n][n];
    // 初始化dp和sum数组
    for (int i = 0; i < n; i++) {
        // 对于长度为1的区间，即只有一个馅饼的情况，当前拥有决策者令牌的参与者可以直接拿走该馅饼的所有切片
        dp[i][i] = slices[i];
        // 对于长度为1的区间，切片总数就是该馅饼的切片数
        sum[i][i] = slices[i];
    }
    // 从长度为2开始，逐渐增加区间的长度，直到长度为n
    for (int len = 2; len <= n; len++) {
        // 遍历所有可能的区间起点
        for (int i = 0; i <= n - len; i++) {
            // 计算区间的终点
            int j = i + len - 1;
            // 计算区间内的切片总数，等于左边的区间的切片总数加上右边的馅饼的切片数
            sum[i][j] = sum[i][j - 1] + slices[j];
            // 计算当前拥有决策者令牌的参与者的最优策略，有两种选择：
            // 1. 拿走左边的馅饼，然后将决策者令牌交给对方，此时自己能获得的切片数等于左边的馅饼的切片数加上对方在剩余区间内的最小切片数
            // 2. 拿走右边的馅饼，然后将决策者令牌交给对方，此时自己能获得的切片数等于右边的馅饼的切片数加上对方在剩余区间内的最小切片数
            // 对方在剩余区间内的最小切片数等于剩余区间内的切片总数减去对方的最大切片数，即sum[i][j] - dp[i][j]
            // 选择两种方案中的较大值作为最优策略
            dp[i][j] = max(slices[i] + sum[i + 1][j] - dp[i + 1][j], slices[j] + sum[i][j - 1] - dp[i][j - 1]);
        }
    }
    // 输出结果，dp[0][n - 1]表示从第一个馅饼到最后一个馅饼的区间内，当前拥有决策者令牌的参与者的最大切片数，即鲍勃的切片数
    // sum[0][n - 1]表示从第一个馅饼到最后一个馅饼的区间内的切片总数，减去鲍勃的切片数，即爱丽丝的切片数
    printf("%d %d\n", sum[0][n - 1] - dp[0][n - 1], dp[0][n - 1]);
}

// 主函数，用于读取输入数据并调用求解函数
int main() {
    // 定义一个变量，用于存储馅饼的个数
    int n;
    // 读取馅饼的个数
    scanf("%d", &n);
    // 定义一个数组，用于存储每个馅饼的切片数
    int slices[n];
    // 读取每个馅饼的切片数
    for (int i = 0; i < n; i++) {
        scanf("%d", &slices[i]);
    }
    // 调用求解函数
    pie_rule(n, slices);
    // 返回0，表示程序正常结束
    return 0;
}

